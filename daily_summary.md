// 看了很多别人如何学习算法的文章，公众号，收藏了很多关于数据结构与算法的书籍，但是现在才发现，最重要的是行动起来，刻意练习，每日精进。这篇 md 记录每天的算法知识。定个小目标：坚持21天，养成一个习惯。

# 2020-03-01
> 编写一段计算机程序一般都是实现一种已有的方法来解决某个问题。这种方法大多和使用的编程语言无关——它适用于各种计算机以及编程语言。是这种方法而非计算机程序本身描述了解决问题的步骤。在计算机科学领域，我们用算法这个词来描述一种有限、确定、有效的并适合用计算机程序来实现的解决问题的方法。**算法**是计算机科学的基础，是这个领域研究的核心。

程序=数据结构+算法，现在写的面向数据库crud之所以简单，是因为底层框架帮我们做了很多事情，而且不用算法的差别在数据量小时也感受不深，但是一旦需要考虑性能的时候，它的威力就会体现的淋漓尽致。

# 2020-03-02

> 我们关注的大多数算法都需要适当地组织数据，而为了组织数据就产生了数据结构，数据结构 也是计算机科学研究的核心对象，它和算法的关系非常密切。在本书中，我们的观点是数据结构是 算法的副产品或是结果，因此要理解算法必须学习数据结构。  
当用计算机解决一个问题时，一般都存在多种不同的方法。对于小型问题，只要管用，方法的 不同并没有什么关系。但是对于大型问题(或者是需要解决大量小型问题的应用)，我们就需要设 计能够有效利用时间和空间的方法了。

> **大O时间复杂度**实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化**趋势**，所以，也叫作渐进时间复杂度(asymptotic time complexity)，简称时间复杂度。

常见的时间复杂度量级：
- 常量阶 O(1)
- 对数阶 O(logn)
- 线性阶 O(n)
- 线性对数阶 O(nlogn)
- 平方阶 O(n^2) 立方阶 O(n^3) ...
- 指数阶 O(2^n)
- 阶乘阶 O(n!)

## 复杂度分析的4个概念
1.最坏情况时间复杂度:代码在最坏情况下执行的时间复杂度。  
2.最好情况时间复杂度:代码在最理想情况下执行的时间复杂度。  
3.平均时间复杂度:用代码在所有情况下执行的次数的加权平均值表示。  
4.均摊时间复杂度:在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。

之所以引入这些概念，是由于同一段代码，在不同输入的情况下，复杂度量级有可能是不一样的。

# 2020-03-03
## Q:为什么大多数编程语言中，数组要从0开始编号，而不是从1开始呢?  
从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移(offset)”。前面也讲到，如果用a来表示数组的首地址，a[0]就是偏移为0的位置，也就是首地址，a[k]就表示偏移k个type_size的位置，所以计算a[k]的内存地址只需要用这个公式:  
`a[k]_address = base_address + k * type_size`  
但是，如果数组从1开始计数，那我们计算数组元素a[k]的内存地址就会变为:   
`a[k]_address = base_address + (k-1)*type_size`  

对比两个公式，我们不难发现，从1开始编号，每次随机访问数组元素都多了一次减法运算，对于CPU来说，就是多了一次减法指令。 数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了**减少一次减法操作**，数组选择了从0开始编号，而不是从1开始。

## 线性表和数组的概念
线性表是最简单、最基本、最常用的一种数据结构，几乎所有线性关系都可以用线性表表示。线性表是线性结构的抽象，线性结构的特点是数据元素之间具有一对一的线性关系，数据元素“一个接一个地排列”。因此，线性表可以想象为一种数据元素的序列。  

线性表有顺序存储和链式存储两种存储方法，基本操作包括插入、删除和查找等。  

数组(Array)是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。  
数组与链表的区别：数组支持**随机访问**，**根据下标随机访问**的时间复杂度为 O(1)。  


# 2020-03-04

> 缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的CPU缓存、数据库缓存、浏览器缓存等等。
缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留?这就需要缓存淘汰策略来决定。常见的策略有三种:先进先出策 略FIFO(First In，First Out)、最少使用策略LFU(Least Frequently Used)、最近最少使用策略LRU(Least Recently Used)。

**链表**（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。  
节点中通常存储数据和下一个节点的地址。
常见的链表结构有：单链表、双向链表和循环链表。  
单链表的第一个节点称为头节点，而最后一个节点称为尾节点，头节点记录链表的基地址。有了它，我们就可以遍历得到整条链表。而尾结点特殊的地方是:指针不是指向下一个结点，而是指向一个空地址NULL，表示这是链表上最后一个结点。  
循环链表是一种特殊的单链表。实际上，循环链表也很简单。它跟单链表唯一的区别就在尾结点。我们知道，单链表的尾结点指针指向空地址，表示这就是最后的结点了。而循环链表的尾结点指针是指向链表的头结点。  
单向链表只有一个方向，结点只有一个后继指针next指向后面的结点。而双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针next指向后面的结点，还有一个前驱指针prev指向前面的结点。

数组与链表的区别：数组支持**随机访问**，**根据下标随机访问**的时间复杂度为 O(1)。  
## Q:如何实现LRU缓存淘汰算法?
基于单链表实现： 

维护一个有序单链表，越靠近链表尾部的节点是越早之前访问的。当有一个新的数据被访问时，从链表头开始顺序遍历链表。   

1. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。

2. 如果此数据没有在缓存链表中，又可以分为两种情况:
- 如果此时缓存未满，则将此结点直接插入到链表的头部;
- 如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。  

因为不管缓存有没有满，我们都需要遍历一遍链表，所以这种基于单链表的实现思路，缓存访问的时间复杂度
为O(n)。

基于数组实现：

首位置保存最新访问数据，末尾位置优先清理 

1. 如果访问的数据存在于缓存的数组中时，查找到数据并将其插入数组的第一个位置，此时亦需移动数组元素，时间复杂度为O(n)。
2. 如果访问的数据未存在于缓存的数组中，分两种情况：
- 如果数组未满，直接将数据插入数组第一个元素位置，此时数组所有元素需要向后移动1个位置，时间复杂度为O(n)；  
- 如果数组已满，则删除末尾的数据，再将数据插入第一个元素位置。

 
# 2020-03-05

## Q：如何判断一个字符串为回文串，假如字符串是用单链表存储的，又该如何判断，相应的时间复杂度是多少？

这个问题跟 [leetcode 234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/) 相似。  
官方解法如下：
1. 找到前半部分链表的尾节点。(快慢指针法)
2. 反转后半部分链表。
3. 判断是否为回文。
4. 恢复链表。
5. 返回结果。 

「回文串」是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。  
「快慢指针法」指的是使用两种指针，慢指针一次走一步，快指针一次走两步，快慢指针同时出发。当快指针移动到链表的末尾时，慢指针到链表的中间。通过慢指针将链表分为两部分。为的是找到中间的节点。


2020-03-06

今天还在练习链表的相关实现，
- 单链表的插入、删除
- 单链表反转
- 链表中环的检测
- 两个有序的链表合并
- 删除链表倒数第n个结点
- 求链表的中间结点

理解指针的含义：将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。  
例如：`p->next = q` , 意味着 p节点中的 next指针存储了 q节点的内存地址。

还有一个更复杂的，也是我们写链表代码经常会用到的:`p->next = p->next->next`。这行代码表示，p结点的next指针存储了p结点的下下一个结点的内存地址。相当于删除p节点的下个节点，当然假如下个节点是尾节点不能这样删除。

利用“哨兵”简化实现难度  
1.什么是“哨兵”？  
链表中的“哨兵”节点是解决边界问题的，不参与业务逻辑。如果我们引入“哨兵”节点，则不管链表是否为空，head指针都会指向这个“哨兵”节点。我们把这种有“哨兵”节点的链表称为带头链表，相反，没有“哨兵”节点的链表就称为不带头链表。  
2.未引入“哨兵”的情况  
如果在p节点后插入一个节点，只需2行代码即可搞定：  
```
new_node—>next = p—>next;
p—>next = new_node;
```
但，若向空链表中插入一个节点，则代码如下：
```
if(head == null){
head = new_node;
}
```
如果要删除节点p的后继节点，只需1行代码即可搞定：
```
p—>next = p—>next—>next;
```
但，若是删除链表的最有一个节点（链表中只剩下这个节点），则代码如下：
```
if(head—>next == null){
head = null;
}
```
从上面的情况可以看出，针对链表的插入、删除操作，需要对插入第一个节点和删除最后一个节点的情况进行特殊处理。这样代码就会显得很繁琐，所以引入“哨兵”节点来解决这个问题。

“哨兵”节点不存储数据，无论链表是否为空，head指针都会指向它，作为链表的头结点始终存在。这样，插入第一个节点和插入其他节点，删除最后一个节点和删除其他节点都可以统一为相同的代码实现逻辑了。

重点留意边界条件处理  
经常用来检查链表是否正确的边界4个边界条件：  
1. 如果链表为空时，代码是否能正常工作？
2. 如果链表只包含一个节点时，代码是否能正常工作？
3. 如果链表只包含两个节点时，代码是否能正常工作？
4. 代码逻辑在处理头尾节点时是否能正常工作？
