// 看了很多别人如何学习算法的文章，公众号，收藏了很多关于数据结构与算法的书籍，但是现在才发现，最重要的是行动起来，刻意练习，每日精进。这篇 md 记录每天的算法知识。定个小目标：坚持21天，养成一个习惯。

# 2020-03-01
> 编写一段计算机程序一般都是实现一种已有的方法来解决某个问题。这种方法大多和使用的编程语言无关——它适用于各种计算机以及编程语言。是这种方法而非计算机程序本身描述了解决问题的步骤。在计算机科学领域，我们用算法这个词来描述一种有限、确定、有效的并适合用计算机程序来实现的解决问题的方法。**算法**是计算机科学的基础，是这个领域研究的核心。

程序=数据结构+算法，现在写的面向数据库crud之所以简单，是因为底层框架帮我们做了很多事情，而且不用算法的差别在数据量小时也感受不深，但是一旦需要考虑性能的时候，它的威力就会体现的淋漓尽致。

# 2020-03-02

> 我们关注的大多数算法都需要适当地组织数据，而为了组织数据就产生了数据结构，数据结构 也是计算机科学研究的核心对象，它和算法的关系非常密切。在本书中，我们的观点是数据结构是 算法的副产品或是结果，因此要理解算法必须学习数据结构。  
当用计算机解决一个问题时，一般都存在多种不同的方法。对于小型问题，只要管用，方法的 不同并没有什么关系。但是对于大型问题(或者是需要解决大量小型问题的应用)，我们就需要设 计能够有效利用时间和空间的方法了。

> **大O时间复杂度**实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化**趋势**，所以，也叫作渐进时间复杂度(asymptotic time complexity)，简称时间复杂度。

常见的时间复杂度量级：
- 常量阶 O(1)
- 对数阶 O(logn)
- 线性阶 O(n)
- 线性对数阶 O(nlogn)
- 平方阶 O(n^2) 立方阶 O(n^3) ...
- 指数阶 O(2^n)
- 阶乘阶 O(n!)

## 复杂度分析的4个概念
1.最坏情况时间复杂度:代码在最坏情况下执行的时间复杂度。  
2.最好情况时间复杂度:代码在最理想情况下执行的时间复杂度。  
3.平均时间复杂度:用代码在所有情况下执行的次数的加权平均值表示。  
4.均摊时间复杂度:在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。

之所以引入这些概念，是由于同一段代码，在不同输入的情况下，复杂度量级有可能是不一样的。

# 2020-03-03
## Q:为什么大多数编程语言中，数组要从0开始编号，而不是从1开始呢?  
从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移(offset)”。前面也讲到，如果用a来表示数组的首地址，a[0]就是偏移为0的位置，也就是首地址，a[k]就表示偏移k个type_size的位置，所以计算a[k]的内存地址只需要用这个公式:  
`a[k]_address = base_address + k * type_size`  
但是，如果数组从1开始计数，那我们计算数组元素a[k]的内存地址就会变为:   
`a[k]_address = base_address + (k-1)*type_size`  

对比两个公式，我们不难发现，从1开始编号，每次随机访问数组元素都多了一次减法运算，对于CPU来说，就是多了一次减法指令。 数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了**减少一次减法操作**，数组选择了从0开始编号，而不是从1开始。

## 线性表和数组的概念
线性表是最简单、最基本、最常用的一种数据结构，几乎所有线性关系都可以用线性表表示。线性表是线性结构的抽象，线性结构的特点是数据元素之间具有一对一的线性关系，数据元素“一个接一个地排列”。因此，线性表可以想象为一种数据元素的序列。  

线性表有顺序存储和链式存储两种存储方法，基本操作包括插入、删除和查找等。  

数组(Array)是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。  
数组与链表的区别：数组支持**随机访问**，**根据下标随机访问**的时间复杂度为 O(1)。  


# 2020-03-04

> 缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的CPU缓存、数据库缓存、浏览器缓存等等。
缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留?这就需要缓存淘汰策略来决定。常见的策略有三种:先进先出策 略FIFO(First In，First Out)、最少使用策略LFU(Least Frequently Used)、最近最少使用策略LRU(Least Recently Used)。

**链表**（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。  
节点中通常存储数据和下一个节点的地址。
常见的链表结构有：单链表、双向链表和循环链表。  
单链表的第一个节点称为头节点，而最后一个节点称为尾节点，头节点记录链表的基地址。有了它，我们就可以遍历得到整条链表。而尾结点特殊的地方是:指针不是指向下一个结点，而是指向一个空地址NULL，表示这是链表上最后一个结点。  
循环链表是一种特殊的单链表。实际上，循环链表也很简单。它跟单链表唯一的区别就在尾结点。我们知道，单链表的尾结点指针指向空地址，表示这就是最后的结点了。而循环链表的尾结点指针是指向链表的头结点。  
单向链表只有一个方向，结点只有一个后继指针next指向后面的结点。而双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针next指向后面的结点，还有一个前驱指针prev指向前面的结点。

数组与链表的区别：数组支持**随机访问**，**根据下标随机访问**的时间复杂度为 O(1)。  
## Q:如何实现LRU缓存淘汰算法?
基于单链表实现： 

维护一个有序单链表，越靠近链表尾部的节点是越早之前访问的。当有一个新的数据被访问时，从链表头开始顺序遍历链表。   

1. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。

2. 如果此数据没有在缓存链表中，又可以分为两种情况:
- 如果此时缓存未满，则将此结点直接插入到链表的头部;
- 如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。  

因为不管缓存有没有满，我们都需要遍历一遍链表，所以这种基于单链表的实现思路，缓存访问的时间复杂度
为O(n)。

基于数组实现：

首位置保存最新访问数据，末尾位置优先清理 

1. 如果访问的数据存在于缓存的数组中时，查找到数据并将其插入数组的第一个位置，此时亦需移动数组元素，时间复杂度为O(n)。
2. 如果访问的数据未存在于缓存的数组中，分两种情况：
- 如果数组未满，直接将数据插入数组第一个元素位置，此时数组所有元素需要向后移动1个位置，时间复杂度为O(n)；  
- 如果数组已满，则删除末尾的数据，再将数据插入第一个元素位置。

 
# 2020-03-05

## Q：如何判断一个字符串为回文串，假如字符串是用单链表存储的，又该如何判断，相应的时间复杂度是多少？

这个问题跟 [leetcode 234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/) 相似。  
官方解法如下：
1. 找到前半部分链表的尾节点。(快慢指针法)
2. 反转后半部分链表。
3. 判断是否为回文。
4. 恢复链表。
5. 返回结果。 

「回文串」是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。  
「快慢指针法」指的是使用两种指针，慢指针一次走一步，快指针一次走两步，快慢指针同时出发。当快指针移动到链表的末尾时，慢指针到链表的中间。通过慢指针将链表分为两部分。为的是找到中间的节点。